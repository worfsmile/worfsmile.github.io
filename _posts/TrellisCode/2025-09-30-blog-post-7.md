---
title: 'trellis3d-code1'
date: 2025-09-30
permalink: /posts/2025/09/blog-post-7/
tags:
series: TrellisCode
---

# Code for Trellis3D - Dataset1

code parts:

- dataset loading
- raw data processing
- feature extraction

Dataset
=======

TRELLIS-main/dataset_toolkits

- codes function
- default parameters
- data structure

1. load_data

```python
if __name__ == '__main__':
    def download(metadata, output_dir, **kwargs):    
        os.makedirs(os.path.join(output_dir, 'raw'), exist_ok=True)

        # 下载dataset
        if not os.path.exists(os.path.join(output_dir, 'raw', 'abo-3dmodels.tar')):
            try:
                os.makedirs(os.path.join(output_dir, 'raw'), exist_ok=True)
                os.system(f"wget -O {output_dir}/raw/abo-3dmodels.tar https://amazon-berkeley-objects.s3.amazonaws.com/archives/abo-3dmodels.tar")
            except:
                print("\033[93m")
                print("Error downloading ABO dataset. Please check your internet connection and try again.")
                print("Or, you can manually download the abo-3dmodels.tar file and place it in the {output_dir}/raw directory")
                print("Visit https://amazon-berkeley-objects.s3.amazonaws.com/index.html for more information")
                print("\033[0m")
                raise FileNotFoundError("Error downloading ABO dataset")
        
        downloaded = {}
        metadata = metadata.set_index("file_identifier")
        with tarfile.open(os.path.join(output_dir, 'raw', 'abo-3dmodels.tar')) as tar:
            with ThreadPoolExecutor(max_workers=1) as executor, \
                tqdm(total=len(metadata), desc="Extracting") as pbar:
                def worker(instance: str) -> str:
                    try:
                        tar.extract(f"3dmodels/original/{instance}", path=os.path.join(output_dir, 'raw'))
                        sha256 = get_file_hash(os.path.join(output_dir, 'raw/3dmodels/original', instance))
                        pbar.update()
                        return sha256
                    except Exception as e:
                        pbar.update()
                        print(f"Error extracting for {instance}: {e}")
                        return None
                    
                sha256s = executor.map(worker, metadata.index)
                executor.shutdown(wait=True)

        for k, sha256 in zip(metadata.index, sha256s):
            if sha256 is not None:
                if sha256 == metadata.loc[k, "sha256"]:
                    downloaded[sha256] = os.path.join('raw/3dmodels/original', k)
                else:
                    print(f"Error downloading {k}: sha256s do not match")

        return pd.DataFrame(downloaded.items(), columns=['sha256', 'local_path'])   # 建立hash与文件路径的映射表


    # dataset_utils = importlib.import_module(f'datasets.{sys.argv[1]}')
    dataset_utils = importlib.import_module(f'datasets.ABO')

    parser = argparse.ArgumentParser()
    parser.add_argument('--output_dir', type=str, default='/mnt/data/zsy/datasets/3D/ABO',
                        help='Directory to save the metadata')
    parser.add_argument('--filter_low_aesthetic_score', type=float, default=None,
                        help='Filter objects with aesthetic score lower than this value')
    parser.add_argument('--instances', type=str, default=None,
                        help='Instances to process')
    dataset_utils.add_args(parser)
    parser.add_argument('--rank', type=int, default=0)
    parser.add_argument('--world_size', type=int, default=2)
    opt = parser.parse_args(sys.argv[2:])
    opt = edict(vars(opt))

    os.makedirs(opt.output_dir, exist_ok=True)

    # get file list
    if not os.path.exists(os.path.join(opt.output_dir, 'metadata.csv')):
        raise ValueError('metadata.csv not found')
    metadata = pd.read_csv(os.path.join(opt.output_dir, 'metadata.csv'))
    if opt.instances is None:   # 筛数据
        if opt.filter_low_aesthetic_score is not None:
            metadata = metadata[metadata['aesthetic_score'] >= opt.filter_low_aesthetic_score]
        if 'local_path' in metadata.columns:
            metadata = metadata[metadata['local_path'].isna()]
    else:
        if os.path.exists(opt.instances):
            with open(opt.instances, 'r') as f:
                instances = f.read().splitlines()
        else:
            instances = opt.instances.split(',')
        metadata = metadata[metadata['sha256'].isin(instances)]

    start = len(metadata) * opt.rank // opt.world_size
    end = len(metadata) * (opt.rank + 1) // opt.world_size
    metadata = metadata[start:end]
    
    # metadata = metadata.head(50)
                
    print(f'Processing {len(metadata)} objects...')

    # process objects
    downloaded = dataset_utils.download(metadata, **opt)
    downloaded.to_csv(os.path.join(opt.output_dir, f'downloaded_{opt.rank}.csv'), index=False)
```

Next
======

2. render
