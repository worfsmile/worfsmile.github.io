---
title: 'trellis3d-code flowing matching'
date: 2025-10-12
permalink: /posts/2025/10/blog-post-12/
tags:
series: TrellisCode
---

Flowing Matching
======

## 一些要注意的点

这里面进入预测$v$的模型时, $t\times 1000$了, 但是其实没有影响, 可以理解为 1000 是模型的一部分
`pred = self.training_models['denoiser'](x_t, t * 1000, cond, **kwargs)` 进 model 时 x1000 (train)
``

## Code Rectified flow

```python
def sample(
    self,
    model,
    noise,
    cond: Optional[Any] = None,
    steps: int = 50,
    rescale_t: float = 1.0,
    verbose: bool = True,
    **kwargs
):
    """
    Generate samples from the model using Euler method.
    
    Args:
        model: The model to sample from.
        noise: The initial noise tensor.
        cond: conditional information.
        steps: The number of steps to sample.
        rescale_t: The rescale factor for t.
        verbose: If True, show a progress bar.
        **kwargs: Additional arguments for model_inference.

    Returns:
        a dict containing the following
        - 'samples': the model samples.
        - 'pred_x_t': a list of prediction of x_t.
        - 'pred_x_0': a list of prediction of x_0.
    """
    sample = noise  # [4, [68704], 8]]]
    t_seq = np.linspace(1, 0, steps + 1)    # array([1.  , 0.98, 0.96, 0.94, 0.92, 0.9 , 0.88, 0.86, 0.84, 0.82, 0.8 ,
    t_seq = rescale_t * t_seq / (1 + (rescale_t - 1) * t_seq)   # rescale_t
    t_pairs = list((t_seq[i], t_seq[i + 1]) for i in range(steps))
    ret = edict({"samples": None, "pred_x_t": [], "pred_x_0": []})
    for t, t_prev in tqdm(t_pairs, desc="Sampling", disable=not verbose):
        out = self.sample_once(model, sample, t, t_prev, cond, **kwargs)
        sample = out.pred_x_prev
        ret.pred_x_t.append(out.pred_x_prev)
        ret.pred_x_0.append(out.pred_x_0)
    ret.samples = sample
    return ret

def sample_once(
    self,
    model,
    x_t,
    t: float,
    t_prev: float,
    cond: Optional[Any] = None,
    **kwargs
):
    """
    Sample x_{t-1} from the model using Euler method.
    
    Args:
        model: The model to sample from.
        x_t: The [N x C x ...] tensor of noisy inputs at time t.
        t: The current timestep.
        t_prev: The previous timestep.
        cond: conditional information.
        **kwargs: Additional arguments for model inference.

    Returns:
        a dict containing the following
        - 'pred_x_prev': x_{t-1}.
        - 'pred_x_0': a prediction of x_0.
    """
    pred_x_0, pred_eps, pred_v = self._get_model_prediction(model, x_t, t, cond, **kwargs)  # x_t = noise
    pred_x_prev = x_t - (t - t_prev) * pred_v
    return edict({"pred_x_prev": pred_x_prev, "pred_x_0": pred_x_0})

def _get_model_prediction(self, model, x_t, t, cond=None, **kwargs):
    pred_v = self._inference_model(model, x_t, t, cond, **kwargs)
    pred_x_0, pred_eps = self._v_to_xstart_eps(x_t=x_t, t=t, v=pred_v)
    return pred_x_0, pred_eps, pred_v   # x_0 预测原始图, eps 预测噪声, v 预测速度

def _v_to_xstart_eps(self, x_t, t, v):
    assert x_t.shape == v.shape
    eps = (1 - t) * v + x_t
    x_0 = (1 - self.sigma_min) * x_t - (self.sigma_min + (1 - self.sigma_min) * t) * v
    return x_0, eps
```

## 原理

假设 $x_0$ 是初始图像 $t=0$, $x_T$ 是噪声 $t = T$, 通常情况下, $T=1$

则有 $v = x_1 - x_0$

$$
\begin{align*}
&t*v = x_t - x_0 \\
\end{align*}
$$

其中 $v$ 是速度,

整流下 $v$ 不变

$$
\begin{align*}
&x_t = (1-t)x_0 + t*x_1 \\
\end{align*}
$$

预测 v(t, x_t)

其中 $x_t = x_{t-1} + v\delta t$

## 对比一下diffusion

加噪去噪
加噪变为正态分布

获得某个时间点
$x_t = \sqrt{\hat{\alpha_t}}x_0 + \sqrt{1-\hat{\alpha_t}}\epsilon$
获得加噪图像
预测 $\epsilon(t, x_t)$

逐步去噪就是加噪的逆过程
加噪
$x_t = \sqrt{1-\beta_t}x_{t-1} + \sqrt{\beta_t}\epsilon$
